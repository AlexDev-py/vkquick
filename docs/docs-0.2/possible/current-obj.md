Когда вы запускаете бота через `$ bot run`, __vkquick__ создает некоторые объекты, живующие на протяжении всей работы бота. Получить эти объекты можно через подмодуль `current`, т.е. `vq.current.`



## Bot (bot)
> В скобках указано имя инстанса

Самый главный из всех самых главных объектов, контролирующий ловлю и обработку событий. Является датаклассом, поэтому этапи инициализации мы разбирать не будем, как и с API

### Поля
Поле|Тип|Описание
-|-|-
`token`|str|Токен пользвоателя/группы, от чьего лица ведутся запросы
`group_id`|int|ID группы, от лица которой работает бот
`debug`|bool|Включен ли режим дебага
`config`|dict|Содержимое `config.toml`
`version`|str|Версия API
`wait`|int|Время ожидания ответа LongPoll сервера
`owner`|Literal["group", "user"]|Владелец токена
`signals`|list|Список обрабатываемых сигналов
`reactions`|list|Список обрабатываемые реакций
`lp`|LongPoll|Текущий инстанс LongPoll
`reaload_now`|bool|При `True` выключат бота. Используется для автоперезагрузки

!!! todo
    Планируется избавиться от лишних полей, посколько большая половина из них есть в `config`

### Методы
#### run
Запускает LongPoll процесс, вызывая перед этим `startup`, а в конце и `shutdown` сигналы

### О signals и reactions
Это списки с соответсвующими объектами, но при этом с некоторыми дополнительными методами. Почти всех их можно можно _считать_ приватными, поскольку они используются для низкоуровнего управления и в 99% случаев вам не понадобятся, однако, они описаны в секции `low-level управление` (которую я еще не написал).

Единственный метод, о котором можно здесь поговорить — это корутинный метод у `signals` — `resolve`, используемый для обработки сигналов. О нем пойдет речь [в разделе про сигналы](signals.md)

`async def resolve(self, name: str, /,  *args, **kwargs)`

Вызывая его вы передаете имя обрабатываемого сигнала в параметр `name` и аргумент, которые принимает этот сигнал в \*args и \*\*kwargs.


## API
Быстрое обращение к API методам вк

### Поля
Поле|Тип|Описание
-|-|-
`token`|str|Токен пользвоателя/группы, от чьего лица ведутся запросы
`group_id`|int|ID группы, от лица которой работает бот
`owner`|Literal["group", "user"]|Владелец токена
`version`|str|Версия используемого API
`factory`|type|Фабрика для возвращаемых ответов. По умолчанию это `attrdict.AttrMap`, что позовляет обращаться к полям ответа через точку и как к словарю
`URL`|str|URL отправляемых запросов. По умолчанию `https://api.vk.com/method/`

### Методы
Каждый из методов поддерживает конвертацию snake_case в CamelCase для имен методов (чтобы соблюдать рекомендации PEP8)

#### `async def method(self, name: str, data: dict)`
Отправляет запрос к API с методом под именем `name` и параметрами `data`

#### `async def __call__(self, as_group_: bool = False, /, **kwargs)`
Вызывает метод, имя которого было получено через `__getattr__`, с параметрами `**kwargs`. При `as_group_=True` (можете использовать `Ellipsis`) в запрос добавится поле `group_id` с ID группы из `config.toml`


!!! Examples
    Вызов метода API, передавая название строкой и параметры словарем
    ```python
    await api.method("users.get", {"user_id": 1})
    ```

    Более кратка запись, используя `__getattr__`
    ```python
    await api.users.get(user_id=1)
    ```

    Конвертация snake_case
    ```python
    await messages.get_conversations_by_id(peer_ids=vq.PEER + 1)
    # Аналогично:
    await messages.getConversationsById(peer_ids=vq.PEER + 1)
    ```

    Автоподставление `group_id` в запрос

    ```python
    await messages.get_conversations_by_id(
        True,
        peer_ids=vq.PEER + 1
    )
    # Аналогично, но используя минималистичную запись объекта Ellipsis ():
    await messages.getConversationsById(
        ..., # Да, это валидный код
        peer_ids=vq.PEER + 1
    )
    ```
    Что составит запрос со следующими полями:
    ```json
    {
        "peer_ids": 2000000001,
        "group_id": <ID группы из конфига>
    }
    ```
