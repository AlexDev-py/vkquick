Сигналы — своего рода кастомные события. "А зачем это нужно?" — возникает очевидный вопрос. Представим, что вы имеете достаточно сложную архитектуру, и поскольку пишете в своего рода функциональном стиле, рефакторите свою логику на более мелкие части (тобишь другие функции), и, скорее всего, разделяя их в разные файлы. Чтобы не погрязнуть в туче импортов, вы можете пометить свою функцию как _обработчик сигнала_ и из любого места в вашем коде вызвать его через имя и передать нужные аргументы

Помимо своих сигналов, вы можете обрабатывать и _встроенные_ сигналы, например, `startup`, вызываемый во время запуска бота и `shutdown` во время выключения бота

Чтобы создать обработчик сигнала (своего или встроенного), воспользуйтесь следующей командой

<div class="termy">
```console
$ bot signal startup
Added a hander on a signal startup into path src/startup.py
```
</div>
Вы заметите, что появился (в нашем случае) файл `src/startup.py` (и добавился импорт в `__init__.py`) вот с таким содержимым

```python
import vkquick as vq


@vq.Signal("startup")
def startup():
    """
    Handler to signal `startup`
    """
```

Появился новый декоратор `Signal`, как раз-таки и говорящий о том, что эта функция — обработчик сигнала. Теперь, когда мы будем запускать нашего бота, перед его началом работы вызовется эта функция (сам обработчик может быть и sync, и async)

---
Теперь попробуем создать свой собственный сигнал

<div class="termy">
```console
$ bot signal example
Added a hander on a signal example into path src/startup.py
```
</div>

Выглядит он почти точно также (кроме имени), как и `startup`, описанный выше. Немного поменяем содержимое, добавив принт

```python hl_lines="9"
import vkquick as vq


@vq.Signal("example")
def example():
    """
    Handler to signal `example`
    """
    print("Called signal `example`")
```

 Теперь можно создать команду, вызывающую этот сигнал

<div class="termy">
```console
$ bot com call_example
Added a command call_example into path src/call_example
```
</div>


Для того, чтобы вызвать сигнал, надо вызвать корутинный метод у `bot`. Считается устаревшим с `v0.2`. Будет удален в `v1`

`async def resolve(self, name: str, /,  *args, **kwargs)`

Либо воспользоваться корутинной функцией, добавленной в `v0.2`:

`async def signal(self, name: str, /,  *args, **kwargs)`

Где `name` — имя сигнала (в нашем случае `example`), а \*аргс и \*\*kwargs — передаваемые параметры в обработчик. Поэтому сделаем команду `async` и добавим вызов сигнала:

```python
import vkquick as vq

from . import config


@vq.Cmd(names=config.NAMES)
@vq.Reaction("message_new")
async def call_example(bot: vq.Bot):
    """
    Handler to command `call_example`
    """
    await bot.signals.resolve("example")
    # либо
    await vq.signal("example")
```

Запускаем бота (`$ bot run --reload --debug`), переходим в лс и пишем `call_example`, после чего смотрим в консоль и видим, что появился вывод ```Called signal `example` ```, что говорит нам о том, что обработчк сигнала вызвался успешно

!!! Note
    Вы также можете вернуть своим сигналом какое-либо значение и далее использовать его

!!! todo
    В v0.3 появится встроенный сигнал, вызываемый после получения нового события

!!! todo
    В планах есть своего рода __репиторы__ (repeators), которые автоматически повторяют тот или иной сигнал (а может и не сигнал) через каждый `n` промежуток
